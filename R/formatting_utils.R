
#' Formats a summary tree into a human-readable text
#'
#' The summary functions returns a machine-readable summary tree. This function
#' takes the summary tree and formats it into a human-readable text.
#'
#' @param summary_tree A list containing the summary tree, or a string with the
#'   path to a file containing the summary tree.
#' @param agenda A list containing the agenda items. It is used to extract a
#'   number of information about each talk, such as the session, title,
#'   speakers, moderators, start and ending times. Agenda sessions/titles must
#'   be consistent with those in the `summary_tree` object.
#' @param event_start_time If agenda timings are in seconds, the starting time
#'   is needed to convert them to actual clock time. If `NULL` it will use the
#'   timing as reported in the agenda.
#' @param output_file A string with the path to the output file. If NULL, the
#'   output is returned invisibly and not written to a file.
#'
#' @return A string containing the formatted summary tree, invisibly. This is
#'   printed to the output file if one is provided.

#' @export
format_summary_tree <- function(
  summary_tree,
  agenda,
  event_start_time = getOption("minutemaker_event_start_time"),
  output_file = NULL
) {
  # Check the consistency of the summary tree and the agenda
  check_agenda_summary_tree_consistency(agenda, summary_tree)

  # If summary_tree is a file path, load the data from the file
  if (is.character(summary_tree) && file.exists(summary_tree)) {
    summary_tree <- dget(summary_tree)
  }

  # Import agenda from file
  if (is.character(agenda)) {
    agenda <- dget(agenda)
  }

  # Initialize the output string
  output <- ""

  # Build the id of each talk using the session and title
  talk_ids <- build_ids_from_agenda(agenda)

  # Loop over each talk id
  for (id in talk_ids) {
    # Extract the summary for the current talk
    talk_summary <- summary_tree[[id]]$summary
    # Extract the agenda element for the current talk
    agenda_element <- agenda[[which(talk_ids == id)]]

    # If no summary is found for the current talk, issue a warning and skip to
    # the next talk
    if (is.null(talk_summary)) {
      cli::cli_warn("No summary found for {.val {id}}. Skipping.")
      next
    }

    # Covert times from second to clock time if possible
    agenda_element <- convert_agenda_times(
      agenda_element,
      convert_to = "clock",
      event_start_time = event_start_time,
      conversion_format = "%R"
    )

    # Generate a text version of the summary, with session, title, speakers,
    # moderators and summary
    # TODO: streamline this repetitive code
    agenda_element$speakers <- stringr::str_flatten_comma(
      agenda_element$speakers
    )
    agenda_element$moderators <- stringr::str_flatten_comma(
      agenda_element$moderators
    )
    agenda_element$session <- ifelse(
      is.null(agenda_element$session),
      "",
      agenda_element$session
    )
    agenda_element$title <- ifelse(
      is.null(
        agenda_element$title
      ),
      "",
      agenda_element$title
    )

    output_piece <- stringr::str_glue_data(
      agenda_element,
      "Session: {session};
    Title: {title};
    Speakers: {speakers};
    Moderators: {moderators};
    Time: {from} - {to};

    {talk_summary}"
    ) |>
      stringr::str_remove_all("\\n?\\w+:\\s*;") # Remove empty fields

    # Append the output piece to the output string
    output <- paste0(output, output_piece, "\n\n####################\n\n")
  }

  # If an output file is specified, write the output to the file
  if (!is.null(output_file)) {
    readr::write_lines(output, output_file)
  }

  # Return the output string invisibly
  invisible(output)
}

#' Formats an agenda into a human-readable text
#'
#' The agenda functions returns a machine-readable agenda. This function takes
#' an agenda in R list format as generated by the `infer_agenda_from_transcript`
#' function and formats it into a human-readable text.
#'
#' @param agenda A list containing the agenda items. It is contains a number of
#'   information about each talk, such as the session, title, speakers,
#'   moderators, start and ending times.
#' @param event_start_time If agenda timings are in seconds, the starting time
#'   is needed to convert them to actual clock time. If `NULL` it will use the
#'   timing as reported in the agenda.
#'
#' @return A string containing the formatted agenda, invisibly.
#'
#' @export
format_agenda <- function(
  agenda,
  event_start_time = getOption("minutemaker_event_start_time")
) {
  # Import agenda from file
  if (is.character(agenda)) {
    agenda <- dget(agenda)
  }

  # Covert times from second to clock time if possible
  agenda <- convert_agenda_times(
    agenda,
    convert_to = "clock",
    event_start_time = event_start_time,
    conversion_format = "%R"
  )

  # Generate a text version of the summary, with session, title, speakers,
  # moderators and summary, if not NULL/empty
  purrr::map_chr(
    agenda,
    ~ {
      .x$speakers <- stringr::str_flatten_comma(.x$speakers)
      .x$moderators <- stringr::str_flatten_comma(.x$moderators)
      .x$session <- ifelse(is.null(.x$session), "", .x$session)
      .x$title <- ifelse(is.null(.x$title), "", .x$title)
      .x$description <- ifelse(is.null(.x$description), "", .x$description)

      stringr::str_glue_data(
        .x,
        "Session: {session};
    Title: {title};
    Description: {description};
    Speakers: {speakers};
    Moderators: {moderators};
    Time: {from} - {to};"
      ) |>
        stringr::str_remove_all("\\n?\\w+:\\s*;") |> # Remove empty fields
        stringr::str_replace_all("\\.;", ";")
    }
  ) |>
    paste(collapse = "\n\n####################\n\n")
}