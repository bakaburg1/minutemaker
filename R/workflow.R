#' Full Speech-To-Summary Workflow Execution
#'
#' This function executes the full speech-to-summary workflow, from the
#' transcription of the audio recording to the generation of the summary tree,
#' to the formatting of the summary tree into a human-readable text.
#'
#' @param target_dir A path to the folder where the summarisation process will
#'   take place. All the intermediate and output files will be stored and looked
#'   for here. It allows encapsulating a single summarisation task from start to
#'   end.
#' @param source_audio A path to an audio file in wav or mp3/4 format. If
#'   `split_audio` is TRUE, it will be split into multiple files which will be
#'   place into the `stt_audio_dir` folder. See `split_audio` for more details.
#' @param split_audio A boolean indicating whether the audio file should be
#'   split into multiple files. Some models, like "Whisper" based ones, can
#'   process files only up to 25 MB. See `split_audio` for more details.
#' @param split_audio_duration The duration of each split audio file in
#'   minutes. 20 minutes equate to more or less 7-8 MB. See `split_audio` for
#'   more details.
#' @param stt_audio_dir A string with the path to the folder where the audio
#'   files to transcribe will be stored. See `split_audio` and
#'   `perform_speech_to_text` for more details. The files in this folder will be
#'   used as input for the speech-to-text model, so you can manually add audio
#'   files to transcribe directly here.
#' @param overwrite_stt_audio A boolean indicating whether the audio files to
#'   transcribe should be overwritten if they already exist.
#' @param transcription_output_dir A string with the path to the folder where
#'   the JSON files generated by the speech-to-text model or an external
#'   transcript will be stored. See `perform_speech_to_text` and
#'   `use_transcript_input` for more details.
#' @param stt_output_dir Deprecated. Use `transcription_output_dir`.
#' @param stt_model A string indicating the speech-to-text model to use. See
#'   `perform_speech_to_text` for more details.
#' @param stt_initial_prompt A string with the path to a file containing the
#'   initial prompt to be used by the speech-to-text model. See
#'   `perform_speech_to_text` for more details.
#' @param stt_language A string indicating the language of the audio file. See
#'   `perform_speech_to_text` for more details.
#' @param extra_stt_args A list containing extra arguments to be passed to the
#'   stt model function. See `perform_speech_to_text` for more details.
#' @param overwrite_transcription_files A boolean indicating whether existing
#'   transcription JSON files should be overwritten. See
#'   `perform_speech_to_text` and `use_transcript_input` for more details.
#' @param enable_llm_correction A boolean indicating whether to apply LLM-based
#'   correction to the transcript.
#' @param transcript_file A path to the output file where the transcript will be
#'   written.
#' @param event_start_time The start time of the event in the HH:MM(:SS)( AM/PM)
#'   format. Will be used to add the actual clock time to the transcript
#'   segments. If NULL, the clock time will not be added. See
#'   `parse_transcript_json()` for more details.
#' @param overwrite_transcript A boolean indicating whether the transcript
#'   output file should be overwritten if it already exists.
#' @param external_transcript A string with the path to the transcript file to
#'   be used instead of performing speech-to-text. It will be picked up
#'   automatically if a .vtt, .srt or .docx file is available in the target
#'   directory. Pass NULL or NA to disable the automatic importation of
#'   transcript files. See `import_transcript_from_file` for more details.
#' @param import_diarization A boolean indicating whether the
#'   speaker should be imported from the external transcript, if present. See
#'   `import_transcript_from_file` for more details.
#' @param chat_file A string with the path to a file containing the chat data.
#'   It will be picked up automatically if a file with "Chat" in its name is
#'   available in the target directory. Pass NULL or NA to disable the automatic
#'   chat file importation. See `add_chat_transcript` for more details. Note
#'   that `event_start_time` must be set if `chat_file` is not NULL.
#' @param chat_format A string indicating the online meeting platform used to
#'   generate the chat file. See `add_chat_transcript` for more details.
#' @param generate_context A logical value indicating whether to generate
#'   meeting context from documentation materials and transcripts before running
#'   the workflow. When TRUE, analyzes materials in the 'documentation' folder
#'   to automatically extract: expected agenda, event description, audience info,
#'   domain vocabulary, and STT initial prompts. This significantly improves
#'   summarization quality by providing domain-specific context to the LLMs.
#'   Generated context takes precedence over manually provided parameters.
#' @param use_agenda Controls whether to use an agenda for summarization.
#'   Possible values are "ask" (interactive prompting), "yes" (use or generate
#'   agenda), or "no" (don't use an agenda).
#' @param agenda_file The path to an agenda file. If use_agenda="yes" and this
#'   file exists, it will be used; otherwise a new agenda will be generated and
#'   saved to this path.
#' @param expected_agenda A character string. Only used if a new agenda is being
#'   generated. This string will be used to guide the LLM while generating the
#'   agenda. See `infer_agenda_from_transcript` for more details.
#' @param agenda_generation_window_size The size of the window in seconds to
#'   analyze at once when generating the agenda. See
#'   `infer_agenda_from_transcript` for more details.
#' @param extra_agenda_generation_args Additional arguments passed to the
#'   `infer_agenda_from_transcript` function. See `infer_agenda_from_transcript`
#'   for more details. Note that the `diarization_instructions` argument for
#'   this function will be taken from the `extra_agenda_generation_args`
#'   argument.
#' @param summarization_method A string indicating the summarization method to
#'   use. See `summarise_full_meeting` for more details.
#' @param multipart_summary If TRUE and an agenda is being used, summarisation
#'   will be done in parts, one for each agenda element using the
#'   `summarise_full_meeting` function. If FALSE, or if use_agenda="no",
#'   summarization will be done in one go using the `summarise_transcript`
#'   function. See the respective functions for more details.
#' @param event_description A string containing a description of the meeting.
#'   See `summarise_transcript` for more details.
#' @param audience A string containing a description of the audience of the
#'   meeting and what to focus on in the summary. See `summarise_transcript` for
#'   more details.
#' @param vocabulary A character vector of specific vocabulary words, names,
#'   definitions, to help the LLM recognise misspellings and abbreviations. See
#'   `summarise_transcript` for more details.
#' @param consider_diarization A logical indicating whether the summarisation
#'   should take into account the diarization of the transcript. See
#'   `summarise_transcript` for more details.
#' @param summary_structure,extra_diarization_instructions,extra_output_instructions
#'   Specific instructions necessary to build the summarisation prompt. See
#'   `summarise_transcript` for more details and run `get_prompts()` to see the
#'   defaults. See `summarise_transcript` for more details.
#' @param llm_provider A string indicating the LLM provider to use for the
#'   summarization. See `summarise_transcript` for more details.
#' @param extra_summarise_args Additional arguments passed to the
#'   `llmR::prompt_llm` function. See `summarise_transcript` for more details.
#' @param summarization_window_size The size of the summarization window in
#'   minutes if the "rolling" method is used. See `summarise_transcript` for
#'   more details.
#' @param summarization_output_length An indication to the LLM regarding the
#'   length of the output in pages. See `summarise_transcript` for more details.
#' @param summarization_output_file A string with the path to the output file
#'   where the summary tree will be written. Should be a .R file. See
#'   `summarise_full_meeting` for more details.
#' @param overwrite_summary_tree A boolean indicating whether the summary tree
#'   output file should be overwritten if it already exists.
#' @param formatted_output_file A string with the path to the output file where
#'   the formatted summary will be written.
#' @param overwrite_formatted_output A boolean indicating whether the formatted
#'   summary output file should be overwritten if it already exists.
#'
#' @return A list containing the transcript data, the summary tree and the
#'   formatted summary.
#'
#' @export
#'
speech_to_summary_workflow <- function(
  target_dir = getwd(),

  # Arguments for `split_audio`
  source_audio = list.files(
    target_dir,
    pattern = ".*\\.(wav|mp\\d)$",
    full.names = TRUE
  )[1],
  split_audio = TRUE,
  split_audio_duration = 40,
  stt_audio_dir = file.path(target_dir, "audio_to_transcribe"),
  overwrite_stt_audio = FALSE,

  # Arguments for `perform_speech_to_text`
  transcription_output_dir = file.path(target_dir, "transcription_output_data"),
  stt_output_dir = lifecycle::deprecated(),
  stt_model = getOption("minutemaker_stt_model"),
  stt_initial_prompt = NULL,
  stt_language = "en",
  extra_stt_args = NULL,
  overwrite_transcription_files = FALSE,

  # Argument for LLM-based transcript correction (enable/disable)
  enable_llm_correction = TRUE,

  # Arguments for `parse_transcript_json`
  transcript_file = file.path(target_dir, "transcript.csv"),
  event_start_time = getOption("minutemaker_event_start_time"),
  overwrite_transcript = FALSE,

  # Arguments for `use_transcript_input`
  external_transcript = list.files(
    target_dir,
    pattern = "\\.(vtt|srt|docx)$",
    ignore.case = TRUE,
    full.names = TRUE
  )[1],
  import_diarization = TRUE,

  # Arguments for `add_chat_transcript`
  chat_file = list.files(
    target_dir,
    pattern = "Chat.*\\.txt$",
    ignore.case = TRUE,
    full.names = TRUE
  )[1],
  chat_format = "webex",
  generate_context = TRUE,

  # Arguments for `summarise_full_meeting` and `infer_agenda_from_transcript`
  use_agenda = c("ask", "yes", "no"),
  agenda_file = file.path(target_dir, "agenda.R"),
  expected_agenda = NULL,
  agenda_generation_window_size = 3600,
  extra_agenda_generation_args = NULL,

  # Arguments for the actual summarization
  multipart_summary = TRUE,
  event_description = NULL,
  audience = "An audience with understanding of the topic",
  vocabulary = NULL,
  consider_diarization = TRUE,
  summary_structure = get_prompts("summary_structure"),
  extra_diarization_instructions = NULL,
  extra_output_instructions = NULL,
  llm_provider = getOption("llmr_llm_provider"),
  extra_summarise_args = NULL,
  summarization_window_size = 15,
  summarization_output_length = if (isTRUE(multipart_summary)) 1 else 3,
  summarization_method = c("simple", "rolling"),

  summarization_output_file = file.path(target_dir, "event_summary.R"),
  overwrite_summary_tree = FALSE,

  # Arguments for `format_summary_tree`
  formatted_output_file = file.path(target_dir, "event_summary.txt"),
  overwrite_formatted_output = FALSE
) {
  if (!rlang::is_string(target_dir) || !nzchar(target_dir)) {
    cli::cli_abort(
      c(
        "Invalid {.code target_dir} provided.",
        "x" = "Received {.val {target_dir}}.",
        "i" = "Pass a folder containing your meeting files (audio and/or transcript).",
        "i" = "If calling from a script, prefer {.code dirname(funr::get_script_path())} rather than the script file path."
      )
    )
  }

  if (lifecycle::is_present(stt_output_dir)) {
    lifecycle::deprecate_warn(
      "0.15.0",
      "stt_output_dir()",
      "transcription_output_dir()",
      details = "The output directory can come from speech-to-text or external transcripts."
    )
    if (missing(transcription_output_dir)) {
      transcription_output_dir <- stt_output_dir
    }
  }

  target_dir <- fs::path_norm(target_dir)
  if (fs::file_exists(target_dir) && !fs::dir_exists(target_dir)) {
    cli::cli_alert_warning(
      "The provided {.path {target_dir}} points to a file. Using its parent directory: {.path {fs::path_dir(target_dir)}}"
    )
    target_dir <- fs::path_dir(target_dir)
  }

  if (!fs::dir_exists(target_dir)) {
    cli::cli_abort(
      c(
        "Target directory not found.",
        "x" = "The path supplied to {.path target_dir} does not exist: {.path {target_dir}}",
        "i" = "Point {.path target_dir} to the folder containing your audio or transcript files."
      )
    )
  }

  summarization_method <- match.arg(summarization_method)
  use_agenda <- match.arg(use_agenda)

  # Initialize agenda variable to track the actual agenda content
  agenda <- NULL

  ## Context Generation ----
  # Generate meeting context from documentation materials to improve summarization quality.
  # This extracts meeting-specific information that helps LLMs produce more accurate and
  # contextually appropriate summaries by providing domain knowledge, vocabulary, and
  # structural information about the meeting.

  if (isTRUE(generate_context)) {
    cli::cli_h2("Context Generation")

    # Determine if we have an external transcript available for context generation.
    # The STT initial prompt is only generated when no external transcript exists,
    # as external transcripts are typically already high-quality and don't need STT hints.
    external_transcript_path <- NULL
    if (
      rlang::is_string(external_transcript) &&
        fs::file_exists(external_transcript)
    ) {
      external_transcript_path <- external_transcript
      cli::cli_alert_info(
        "External transcript available for context generation: {.file {basename(external_transcript)}}"
      )
    }

    # Generate context using the specified strategy (one_pass or agentic).
    # This analyzes documentation materials in the 'documentation' folder and
    # optionally uses transcript content to create meeting-specific context.
    cli::cli_alert("Generating meeting context from documentation materials...")
    context_values <- minutemaker::generate_context(
      target_dir = target_dir,
      material_dir = getOption(
        "minutemaker_context_material_dir",
        "documentation"
      ),
      overwrite = getOption("minutemaker_overwrite_context", FALSE),
      generate_expected_agenda = use_agenda != "no", # Only generate agenda if it will be used
      generate_event_description = TRUE, # Meeting purpose and goals
      generate_audience = TRUE, # Who the meeting is for and focus areas
      generate_vocabulary = TRUE, # Domain-specific terms and abbreviations
      generate_initial_prompt = is.null(external_transcript_path), # STT hints only when needed
      expected_agenda = expected_agenda, # User-provided agenda guidance
      event_description = event_description, # User-provided meeting description
      audience = audience, # User-provided audience info
      vocabulary = vocabulary, # User-provided vocabulary terms
      stt_initial_prompt = stt_initial_prompt, # User-provided STT hints
      external_transcript = external_transcript_path, # Transcript for context (optional)
      llm_provider = llm_provider
    )

    # Integrate generated context into workflow parameters.
    # Generated context takes precedence over user-provided values, with informative alerts.
    if (!is.null(context_values$expected_agenda)) {
      cli::cli_alert_success(
        "Using generated expected agenda for summarization"
      )
      expected_agenda <- context_values$expected_agenda
    }
    if (!is.null(context_values$event_description)) {
      cli::cli_alert_success("Using generated event description")
      event_description <- context_values$event_description
    }
    if (!is.null(context_values$audience)) {
      cli::cli_alert_success("Using generated audience information")
      audience <- context_values$audience
    }
    if (!is.null(context_values$vocabulary)) {
      cli::cli_alert_success(
        "Using generated vocabulary ({length(context_values$vocabulary)} terms)"
      )
      vocabulary <- context_values$vocabulary
    }
    if (!is.null(context_values$stt_initial_prompt)) {
      cli::cli_alert_success("Using generated STT initial prompt")
      stt_initial_prompt <- context_values$stt_initial_prompt
    }

    cli::cli_alert_success("Context generation completed")
  }

  cli::cli_h1("Audio Preprocessing")
  ## Perform audio splitting ##

  # Decide whether to perform STT or use external transcript
  perform_stt <- TRUE
  if (rlang::is_string(external_transcript)) {
    if (fs::file_exists(external_transcript)) {
      cli::cli_alert_info(
        "External transcript found: {.file {basename(external_transcript)}}.
        Bypassing speech-to-text transcription."
      )
      use_transcript_input(
        file = external_transcript,
        target_dir = target_dir,
        import_diarization = import_diarization,
        overwrite = overwrite_transcription_files
      )
      perform_stt <- FALSE
    } else {
      cli::cli_warn(
        "External transcript file not found at {.path {external_transcript}}."
      )
    }
  }

  if (perform_stt) {
    # Check if the stt audio dir is empty or overwrite is TRUE
    if (overwrite_stt_audio || purrr::is_empty(list.files(stt_audio_dir))) {
      if (!rlang::is_string(source_audio) || !fs::file_exists(source_audio)) {
        cli::cli_abort(
          c(
            "No audio found for speech-to-text.",
            "x" = "Expected a valid source audio file but received: {.path {source_audio}}",
            "i" = "Place an audio file in {.path {stt_audio_dir}} or pass it explicitly via {.code source_audio}.",
            "i" = "If you want to start from an existing transcript, supply it via {.code external_transcript} (e.g., a .vtt/.srt/.docx file in {.path {target_dir}})."
          )
        )
      }

      if (isFALSE(split_audio)) {
        # If `split_audio` is FALSE, the audio file will be just copied to the
        # `stt_audio_dir` folder

        if (fs::file_exists(stt_audio_dir) && !fs::dir_exists(stt_audio_dir)) {
          cli::cli_abort(
            c(
              "Destination path for speech-to-text is not a directory.",
              "x" = "Destination path is a file: {.path {stt_audio_dir}}"
            )
          )
        }
        if (!fs::dir_exists(stt_audio_dir)) {
          fs::dir_create(stt_audio_dir)
        }
        if (!fs::dir_exists(stt_audio_dir)) {
          cli::cli_abort(
            c(
              "Failed to create destination directory for speech-to-text.",
              "x" = "Destination path is not a directory: {.path {stt_audio_dir}}"
            )
          )
        }

        cli::cli_alert_info(
          "Moving source audio file to {.path {stt_audio_dir}},
          without modification..."
        )

        copy_ok <- file.copy(source_audio, stt_audio_dir)
        if (!isTRUE(copy_ok)) {
          cli::cli_abort(
            c(
              "Failed to copy source audio for speech-to-text.",
              "x" = "Source: {.path {source_audio}}",
              "x" = "Destination: {.path {stt_audio_dir}}",
              "i" = "Check file permissions, available disk space, and that the destination is writable."
            )
          )
        }
      } else {
        cli::cli_alert("Splitting audio file...")

        # Split the audio file. The split audio will be saved in the
        # "stt_audio_dir" folder in the same directory as the original audio
        # file
        split_audio(
          audio_file = source_audio,
          output_folder = stt_audio_dir,
          segment_duration = split_audio_duration
        )
      }
    } else {
      cli::cli_alert(
        "Loading existing split audio files from {.path {basename(stt_audio_dir)}}..."
      )
    }

    cli::cli_h1("Speech-to-Text Transcription")
    ## Perform speech to text ##

    # Check if the stt output folder is empty or overwrite is TRUE
    if (
      overwrite_transcription_files ||
        length(list.files(transcription_output_dir)) <
          length(list.files(stt_audio_dir))
    ) {
      cli::cli_alert("Performing speech to text...")
      cli::cli_alert_info("(stt model: {stt_model})")

      # A speech-to-text model is required
      if (is.null(stt_model)) {
        cli::cli_abort("No speech-to-text model provided.")
      }

      # Check if the split audio files exist
      if (purrr::is_empty(list.files(stt_audio_dir))) {
        cli::cli_abort("No audio files found in {.path {stt_audio_dir}}")
      }

      stt_args <- c(
        list(
          audio_path = stt_audio_dir,
          output_dir = transcription_output_dir,
          model = stt_model,
          initial_prompt = stt_initial_prompt,
          overwrite = overwrite_transcription_files,
          language = stt_language
        ),
        extra_stt_args
      )

      # Use do.call to pass extra_stt_args to the ... argument
      do.call(perform_speech_to_text, stt_args)
      cli::cli_alert_success("Speech-to-text step completed.")
    } else {
      cli::cli_alert(
        "Loading existing transcript data files from
        {.path {basename(target_dir)}}..." |>
          stringr::str_squish()
      )
    }
  }

  # Check if the STT step was successful
  if (purrr::is_empty(list.files(transcription_output_dir))) {
    cli::cli_abort(
      c(
        "Speech-to-text output directory is missing or empty:
        {.path {transcription_output_dir}}",
        "i" = "Ensure the speech-to-text step completed successfully before continuing the workflow."
      )
    )
  }

  ## Perform LLM-based transcript correction (if enabled) ##
  if (isTRUE(enable_llm_correction)) {
    cli::cli_h1("LLM-based Transcript Correction")
    cli::cli_alert("Applying LLM-based correction to transcript JSON files...")

    # Check if reasoning is enabled via options and issue an advisory message
    minutemaker_reasoning_option <- getOption(
      "minutemaker_include_llm_reasoning",
      TRUE
    )

    if (isTRUE(minutemaker_reasoning_option)) {
      cli::cli_alert_info(
        paste(
          "LLM transcript correction is enabled and",
          "'minutemaker_include_llm_reasoning' is TRUE.",
          "If your correction LLM (set via 'minutemaker_correction_llm_model')",
          "is a reasoning model (e.g. OpenAi o-series or",
          "Google Gemini 2.5 series),",
          "or for potentially faster/cheaper corrections, consider setting",
          "options(minutemaker_include_llm_reasoning = FALSE)."
        )
      )
    }

    # Call apply_llm_correction, allowing it to use its default for
    # include_reasoning and passing the main 'vocabulary' argument for terms.
    apply_llm_correction(
      input_path = transcription_output_dir,
      # Use the 'vocabulary' from speech_to_summary_workflow args
      terms = vocabulary,
      overwrite = overwrite_transcription_files
    )
    cli::cli_alert_success("LLM-based correction step completed.")
  }

  cli::cli_h1("Transcript Processing")
  ## Create the transcript file ##

  # Check if the transcript file doesn't exists or overwrite is TRUE
  if (isTRUE(overwrite_transcript) || !fs::file_exists(transcript_file)) {
    cli::cli_alert("Generating transcript file...")
    # Generate the trascript from the json output data
    transcript_data <- parse_transcript_json(
      transcription_output_dir,
      event_start_time = event_start_time
    )

    # Add chat transcript
    if (!purrr::is_empty(chat_file) && !is.na(chat_file)) {
      cli::cli_alert("Adding chat transcript...")

      if (is.null(event_start_time)) {
        cli::cli_abort("Chat file found but no start time provided.")
      }

      transcript_data <- add_chat_transcript(
        transcript_data = transcript_data,
        chat_transcript = chat_file,
        start_time = event_start_time,
        chat_format = chat_format
      )
    }

    # Write transcript to file
    readr::write_csv(
      transcript_data,
      file = transcript_file
    )
    cli::cli_alert_success(
      "Transcript file created: {.path {basename(transcript_file)}}"
    )
  } else {
    cli::cli_alert(
      "Loading existing transcript from
      {.path {basename(transcript_file)}}..." |>
        stringr::str_squish()
    )

    transcript_data <- readr::read_csv(
      transcript_file,
      show_col_types = FALSE
    )
  }

  cli::cli_h1("Agenda Handling")
  ## Handle agenda selection/generation based on use_agenda parameter ##

  # If use_agenda is "no", set agenda to FALSE and force multipart_summary to
  # FALSE
  if (use_agenda == "no") {
    cli::cli_alert_info("Proceeding without using an agenda, as requested.")
    agenda <- FALSE
    multipart_summary <- FALSE
  } else {
    # Check if agenda file exists
    agenda_file_exists <- rlang::is_string(agenda_file) &&
      fs::file_exists(agenda_file)

    # If use_agenda is "ask" but we're not in interactive mode, treat as "yes"
    if (use_agenda == "ask" && !interactive()) {
      cli::cli_alert_info(
        "Non-interactive session with {.code use_agenda = 'ask'}"
      )
      cli::cli_alert_info("Treating as {.code use_agenda = 'yes'}.")
      use_agenda <- "yes"
    }

    # Define actions as a function to avoid code duplication
    generate_new_agenda <- function() {
      cli::cli_alert(
        "Generating {if(use_agenda == 'yes') 'a' else 'new'} agenda..."
      )

      # Generate a new agenda
      agenda_infer_args <- c(
        list(
          transcript = transcript_data,
          event_description = event_description,
          vocabulary = vocabulary,
          diarization_instructions = extra_diarization_instructions,
          start_time = event_start_time,
          expected_agenda = expected_agenda,
          window_size = agenda_generation_window_size,
          output_file = agenda_file,
          provider = llm_provider
        ),
        extra_agenda_generation_args
      )

      new_agenda <- do.call(infer_agenda_from_transcript, agenda_infer_args)

      # Display the generated agenda for reference
      cli::cli_alert_success(
        "Agenda generated and saved to {.path {basename(agenda_file)}}"
      )
      cli::cli_verbatim("\n", format_agenda(new_agenda), "\n")

      return(new_agenda)
    }

    # Handle "ask" mode with interactive menu
    if (use_agenda == "ask") {
      # Create dynamic choice list based on whether agenda file exists
      choices <- character(0)

      if (agenda_file_exists) {
        choices <- c(
          choices,
          sprintf("Use existing agenda file: %s", basename(agenda_file))
        )
      }

      choices <- c(
        choices,
        "Generate a new agenda automatically",
        "Proceed without an agenda and create one overall summary",
        "Exit"
      )

      # Show the menu
      choice <- utils::menu(
        choices,
        title = "How do you want to proceed with the agenda?"
      )

      # Map the numeric menu selection to an action to reduce nested conditionals
      action <- switch(
        as.character(choice),
        "0" = "exit",
        "1" = if (agenda_file_exists) "use_existing" else "generate",
        "2" = if (agenda_file_exists) "generate" else "no_agenda",
        "3" = if (agenda_file_exists) "no_agenda" else "exit",
        "4" = "exit",
        "exit"
      )

      switch(
        action,
        "exit" = {
          cli::cli_alert_warning(
            "Aborted by user. Returning transcript data only (invisibly)."
          )
          return(invisible(transcript_data))
        },
        "use_existing" = {
          cli::cli_alert_info(
            "Using existing agenda file: {.file {basename(agenda_file)}}"
          )
          agenda <- load_serialized(agenda_file, "agenda")
        },
        "generate" = {
          agenda <- generate_new_agenda()
        },
        "no_agenda" = {
          cli::cli_alert_info("Proceeding without an agenda.")
          agenda <- FALSE
          multipart_summary <- FALSE
        }
      )
    } else if (use_agenda == "yes") {
      # Handle "yes" mode - use existing file or generate new one
      if (agenda_file_exists) {
        cli::cli_alert_info(
          "Using existing agenda file: {.file {basename(agenda_file)}}"
        )

        agenda <- load_serialized(agenda_file, "agenda")
      } else {
        agenda <- generate_new_agenda()
      }
    }
  }

  # If we're not using an agenda (agenda is FALSE), force multipart_summary to
  # FALSE
  if (isFALSE(agenda)) {
    multipart_summary <- FALSE
  }

  if (!isFALSE(agenda) && !is.null(agenda)) {
    agenda <- clean_agenda(
      agenda = agenda,
      transcript_data = transcript_data,
      event_start_time = event_start_time,
      on_empty = "drop"
    )
  }

  cli::cli_h1("Summarization")
  cli::cli_alert("Summarizing transcript...")

  if (is.null(llm_provider)) {
    cli::cli_abort("No LLM provider defined.")
  }

  # Manage situations where the formatted output file exists
  if (
    !purrr::is_empty(formatted_output_file) &&
      fs::file_exists(formatted_output_file)
  ) {
    if (isTRUE(overwrite_formatted_output)) {
      cli::cli_warn(
        c(
          "Overwriting the existing summary output.",
          "i" = "Stop the process if you want to keep the existing file."
        )
      )
    } else if (isFALSE(overwrite_formatted_output)) {
      cli::cli_abort(
        c(
          "The formatted summary output file already exists and overwrite
            is {.code FALSE}.",
          "i" = "Set {.code overwrite_formatted_output = TRUE} to overwrite it
            or remove it."
        )
      )
    } else {
      cli::cli_abort(
        "The {.code overwrite_formatted_output} argument must be
          {.code TRUE} or {.code FALSE}."
      )
    }
  }

  # Common summarization arguments
  summarization_args <- c(
    list(
      transcript_data = transcript_data,
      method = summarization_method,

      window_size = summarization_window_size,
      output_length = summarization_output_length,

      event_description = event_description,
      audience = audience,
      vocabulary = vocabulary,
      consider_diarization = consider_diarization,

      summary_structure = summary_structure,
      extra_diarization_instructions = extra_diarization_instructions,
      extra_output_instructions = extra_output_instructions,

      provider = llm_provider
    ),
    extra_summarise_args
  )

  # If an agenda is available, weave it into the summary structure so prompts
  # stay agenda-aware even when producing a single-part summary.
  if (!isFALSE(agenda) && !is.null(agenda)) {
    summarization_args$summary_structure <- stringr::str_glue(
      "
    {summary_structure}
    Here is an agenda of the event to keep into account while summarizing:
    {format_agenda(agenda)}
    Strictly follow the agenda to understand which information is worth summarizing."
    )
  }

  if (isFALSE(agenda) || isFALSE(multipart_summary)) {
    # Summarize as single talk
    cli::cli_inform("...with single part approach...")

    formatted_summary <- do.call(summarise_transcript, summarization_args)

    return_vec <- c("transcript_data", "formatted_summary")
  } else {
    # Summarize as multiple talks
    cli::cli_inform("...with multipart approach...")

    if (!validate_agenda(agenda)) {
      cli::cli_abort("The agenda is not valid.")
    }

    # Necessary extra arguments for the summarization of whole events
    summarization_args$agenda <- agenda
    summarization_args$overwrite <- overwrite_summary_tree
    summarization_args$output_file <- summarization_output_file
    summarization_args$event_start_time <- event_start_time
    summary_tree <- do.call(summarise_full_meeting, summarization_args)

    cli::cli_h1("Formatting Summary")
    ## Format summary tree ##
    cli::cli_alert("Formatting summary tree...")

    formatted_summary <- format_summary_tree(
      summary_tree = summary_tree,
      agenda = agenda,
      event_start_time = event_start_time,
      output_file = NULL
    )

    return_vec <- c("transcript_data", "summary_tree", "formatted_summary")
  }

  cli::cli_h1("Output Generation")
  cli::cli_alert("Writing to file...")

  readr::write_lines(formatted_summary, formatted_output_file)
  cli::cli_alert_success(
    "Formatted summary written to {.path {basename(formatted_output_file)}}"
  )

  cli::cli_rule()
  cli::cli_alert_success("Workflow completed successfully.")
  cli::cli_rule()

  return(mget(return_vec))
}

#' Generate a workflow template script
#'
#' Copy the meeting summary template script from the package to a target path.
#' This template provides a starting point for running the full workflow.
#'
#' @param path A file path or directory where the template should be written.
#'   If a directory is supplied, the file will be named
#'   `meeting_summary_template.R`.
#' @param overwrite A logical value indicating whether to overwrite an existing
#'   file at the target path.
#'
#' @return The path to the generated template, invisibly.
#' @export
#'
generate_workflow_template <- function(path = ".", overwrite = FALSE) {
  if (!rlang::is_string(path) || is.na(path) || path == "") {
    cli::cli_abort(
      c(
        "Invalid {.arg path} provided.",
        "x" = "Expected a non-empty string."
      )
    )
  }

  template_path <- system.file(
    "templates",
    "meeting_summary_template.R",
    package = "minutemaker"
  )

  if (template_path == "") {
    cli::cli_abort(
      c(
        "Template file not found in the package.",
        "x" = "Expected the template at {.path inst/templates}."
      )
    )
  }

  if (fs::dir_exists(path)) {
    dest_path <- file.path(path, "meeting_summary_template.R")
  } else {
    dest_path <- path
    dest_dir <- dirname(dest_path)
    if (!fs::dir_exists(dest_dir)) {
      fs::dir_create(dest_dir, recurse = TRUE)
    }
  }

  dest_path <- fs::path_abs(dest_path)

  if (file.exists(dest_path) && !isTRUE(overwrite)) {
    cli::cli_abort(
      c(
        "Template already exists at {.path {dest_path}}.",
        "i" = "Set {.arg overwrite} to TRUE to replace it."
      )
    )
  }

  fs::file_copy(template_path, dest_path, overwrite = overwrite)
  cli::cli_alert_success("Template written to {.path {dest_path}}.")

  invisible(dest_path)
}
